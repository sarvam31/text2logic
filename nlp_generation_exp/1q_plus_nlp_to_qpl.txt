

>>>>>>>>>>>>>>>>>>>>Test #1 <<<<<<<<<<<<<<<<<<<<
Input: 
Schema:
TABLE station ( id, name, lat, long, dock_count, city, installation_date );
TABLE status ( station_id, bikes_available, docks_available, time, FOREIGN KEY (station_id) REFERENCES station );
TABLE trip ( id, duration, start_date, start_station_name, start_station_id, end_date, end_station_name, end_station_id, bike_id, subscription_type, zip_code );
TABLE weather ( date, max_temperature_f, mean_temperature_f, min_temperature_f, max_dew_point_f, mean_dew_point_f, min_dew_point_f, max_humidity, mean_humidity, min_humidity, max_sea_level_pressure_inches, mean_sea_level_pressure_inches, min_sea_level_pressure_inches, max_visibility_miles, mean_visibility_miles, min_visibility_miles, max_wind_Speed_mph, mean_wind_speed_mph, max_gust_speed_mph, precipitation_inches, cloud_cover, events, wind_dir_degrees, zip_code );

Question:
What are the names of all stations with a latitude smaller than 37.5?

Natural Language Plan:
#1 = What are the names of all stations with a latitude less than 37.5 
            
QPL Plan:

Gold answer:
#1 = Scan Table [ station ] Predicate [ lat < 37.5 ] Output [ name , lat ]


LLM Response:
#1 = Scan Table [ station ] Predicate [ lat < 37.5 ] Output [ name ]


>>>>>>>>>>>>>>>>>>>>Test #2 <<<<<<<<<<<<<<<<<<<<
Input: 
Schema:
TABLE genre ( g_name, rating, most_popular_in)
TABLE artist ( artist_name, country, gender, preferred_genre)
TABLE files ( f_id, artist_name, file_size, duration, formats)
TABLE song ( song_name, artist_name, country, f_id, genre_is, rating, languages, releasedate, resolution)

Question:
How many Bangladeshi artists are listed?

Natural Language Plan:
#1 = Who are the Bangladeshi artists
#2 = How many Bangladeshi artists are there

QPL Plan:

Gold answer:
#1 = Scan Table [ artist ] Predicate [ country = 'Bangladesh' ] Output [ country ]
#2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]



LLM Response:
#1 = Scan Table [ artist ] Predicate [ country = 'Bangladesh' ] Output [ artist_name ]
#2 = Aggregate [ #1 ] Output [ countstar AS Count_Star ]


>>>>>>>>>>>>>>>>>>>>Test #3 <<<<<<<<<<<<<<<<<<<<
Input: 
Schema:
TABLE station ( id, name, lat, long, dock_count, city, installation_date );
TABLE status ( station_id, bikes_available, docks_available, time, FOREIGN KEY (station_id) REFERENCES station );
TABLE trip ( id, duration, start_date, start_station_name, start_station_id, end_date, end_station_name, end_station_id, bike_id, subscription_type, zip_code );
TABLE weather ( date, max_temperature_f, mean_temperature_f, min_temperature_f, max_dew_point_f, mean_dew_point_f, min_dew_point_f, max_humidity, mean_humidity, min_humidity, max_sea_level_pressure_inches, mean_sea_level_pressure_inches, min_sea_level_pressure_inches, max_visibility_miles, mean_visibility_miles, min_visibility_miles, max_wind_Speed_mph, mean_wind_speed_mph, max_gust_speed_mph, precipitation_inches, cloud_cover, events, wind_dir_degrees, zip_code );

Question:
For each city, return the highest latitude among its stations.

Natural Language Plan:
#1 = What are the latitude and city for each station
#2 = For each city, what is the highest latitude among its stations

QPL Plan:

Gold answer:
#1 = Scan Table [ station ] Output [ lat , city ] ; 
#2 = Aggregate [ #1 ] GroupBy [ city ] Output [ city , MAX(lat) AS Max_lat

LLM Response:
#1 = Scan Table [ station ] Output [ lat , city ]
#2 = Aggregate [ #1 ] GroupBy [ city ] Output [ city , MAX(lat) AS Highest_Latitude ]


>>>>>>>>>>>>>>>>>>>>Test #4 <<<<<<<<<<<<<<<<<<<<
Input: 
Schema:
TABLE station ( id, name, lat, long, dock_count, city, installation_date );
TABLE status ( station_id, bikes_available, docks_available, time, FOREIGN KEY (station_id) REFERENCES station );
TABLE trip ( id, duration, start_date, start_station_name, start_station_id, end_date, end_station_name, end_station_id, bike_id, subscription_type, zip_code );
TABLE weather ( date, max_temperature_f, mean_temperature_f, min_temperature_f, max_dew_point_f, mean_dew_point_f, min_dew_point_f, max_humidity, mean_humidity, min_humidity, max_sea_level_pressure_inches, mean_sea_level_pressure_inches, min_sea_level_pressure_inches, max_visibility_miles, mean_visibility_miles, min_visibility_miles, max_wind_Speed_mph, mean_wind_speed_mph, max_gust_speed_mph, precipitation_inches, cloud_cover, events, wind_dir_degrees, zip_code );

Question:
What is the start station and end station for the trips with the three smallest ids?

Natural Language Plan:
#1 = What are the start station name, end station name and trip id for all trips
#2 = What are the start station name, end station name for top 3 stations sorted by id

QPL Plan:

Gold answer:
#1 = Scan Table [ trip ] Output [ start_station_name , end_station_name , id ]
#2 = Top [ #1 ] Rows [ 3 ] Output [ start_station_name , end_station_name ]

LLM Response:
#1 = Scan Table [ trip ] Output [ start_station_name , end_station_name , id ]
#2 = TopSort [ #1 ] Rows [ 3 ] OrderBy [ id ASC ] Output [ start_station_name , end_station_name ]


>>>>>>>>>>>>>>>>>>>>Test #5 <<<<<<<<<<<<<<<<<<<<
Input: 
Schema:
TABLE genre ( g_name, rating, most_popular_in)
TABLE artist ( artist_name, country, gender, preferred_genre)
TABLE files ( f_id, artist_name, file_size, duration, formats)
TABLE song ( song_name, artist_name, country, f_id, genre_is, rating, languages, releasedate, resolution)

Question:
What is the average rating of songs produced by female artists?

Natural Language Plan:
#1 = Who are the female artists 
#2 = What are the ratings of songs and artist name
#3 = What are the ratings of songs where artists are female
#4 = What is the average rating of songs produced by female artists

QPL Plan:

Gold answer:
#1 = Scan Table [ artist ] Predicate [ gender = 'Female' ] Output [ gender , artist_name ]
#2 = Scan Table [ song ] Output [ rating , artist_name ]
#3 = Join [ #1 , #2 ] Predicate [ #1.artist_name = #2.artist_name ] Output [ #2.rating ]
#4 = Aggregate [ #3 ] Output [ AVG(rating) AS Avg_rating ]

LLM Response:
#1 = Scan Table [ artist ] Predicate [ gender = 'female' ] Output [ artist_name ]
#2 = Scan Table [ song ] Output [ rating , artist_name ]
#3 = Join [ #1 , #2 ] Predicate [ #1.artist_name = #2.artist_name ] Output [ #2.rating ]
#4 = Aggregate [ #3 ] Output [ avg(rating) AS Average_Rating ]


>>>>>>>>>>>>>>>>>>>>Test #6 <<<<<<<<<<<<<<<<<<<<
Input: 
Schema:
TABLE station ( id, name, lat, long, dock_count, city, installation_date );
TABLE status ( station_id, bikes_available, docks_available, time, FOREIGN KEY (station_id) REFERENCES station );
TABLE trip ( id, duration, start_date, start_station_name, start_station_id, end_date, end_station_name, end_station_id, bike_id, subscription_type, zip_code );
TABLE weather ( date, max_temperature_f, mean_temperature_f, min_temperature_f, max_dew_point_f, mean_dew_point_f, min_dew_point_f, max_humidity, mean_humidity, min_humidity, max_sea_level_pressure_inches, mean_sea_level_pressure_inches, min_sea_level_pressure_inches, max_visibility_miles, mean_visibility_miles, min_visibility_miles, max_wind_Speed_mph, mean_wind_speed_mph, max_gust_speed_mph, precipitation_inches, cloud_cover, events, wind_dir_degrees, zip_code );

Question:
What is the zip code in which the average mean sea level pressure is the lowest?

Natural Language Plan:
#1 = What are the zip code and mean sea level pressure
#2 = What is the average mean sea level pressure for each zip code 
#3 = What is the zip code in which average mean sea level pressure is lowest

QPL Plan:

Gold answer:
#1 = Scan Table [ weather ] Output [ zip_code , mean_sea_level_pressure_inches ] ; 
#2 = Aggregate [ #1 ] GroupBy [ zip_code ] Output [ AVG(mean_sea_level_pressure_inches) AS Avg_mean_sea_level_pressure_inches , zip_code ] 
#3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Avg_mean_sea_level_pressure_inches ASC ] Output [ Avg_mean_sea_level_pressure_inches , zip_code ]

LLM Response:
#1 = Scan Table [ weather ] Output [ zip_code , mean_sea_level_pressure_inches ]
#2 = Aggregate [ #1 ] GroupBy [ zip_code ] Output [ zip_code , AVG(mean_sea_level_pressure_inches) AS Avg_Mean_Sea_Level_Pressure ]
#3 = TopSort [ #2 ] Rows [ 1 ] OrderBy [ Avg_Mean_Sea_Level_Pressure ASC ] Output [ zip_code ]
